# One MCP Service Development Plan

## Background and Motivation

The goal is to develop an One MCP (Multi-Cloud Platform) Service. This service acts as a central hub for managing and proxying various underlying MCP services (types: `stdio`, `sse`, `streamable_http`). Users configure these underlying services and then access them through unified SSE or Streamable HTTP endpoints provided by this One MCP service. Users create "MCP Setups" (configuration sets) containing multiple service instances. A key feature is exporting these setups into JSON formats specific to different client applications (e.g., Cursor, Cherry-Studio). The exported configurations will always point to the One MCP service's proxy endpoints, and the protocol used by these proxy endpoints (SSE or Streamable HTTP) is determined by the chosen client application type at export time.

This simplified approach streamlines export by tying the proxy protocol choice directly to the client type.

**New: MCP Server Installation User Experience**
The project will also include a user interface for discovering and installing MCP servers, similar to the experience in C-Line and Cherry Studio.
- **User Interface**: A dedicated UI will allow users to browse and search for available MCP servers.
- **Marketplace Integration**:
    - Users will be able to search for MCP servers from public marketplaces like npm (Node Package Manager) and PyPI (Python Package Index).
    - The system will initially feature a curated list of built-in/recommended servers.
- **Installation Mechanism**:
    - Upon selecting a server, the system will use the appropriate command-line tool to install it:
        - `npx` for npm packages.
        - `uvx` (or equivalent like `pip install`) for PyPI packages.
    - The installed server will then be available within the One MCP system for users to configure and use.

The system needs to support:
- Admins defining abstract MCP Service types (`MCPService`), including:
    - The underlying type of the service (`stdio`, `sse`, `streamable_http`).
    - Schemas for admin-level and user-level configurations.
    - Default values for admin configurations.
    - Rules on user overrides.
    - `ClientConfigTemplates` (JSON/TEXT): A map where keys are `client_type` strings (e.g., "cursor", "cherry_studio"). Each value is an object with:
        - `template_string` (string): The Go template for the client-specific JSON snippet.
        - `client_expected_protocol` (string): The protocol type (e.g.,"sse", "streamable_http", "stdio") the client expects for this service entry in its config file.
        - `our_proxy_protocol_for_this_client` (string): The protocol ("sse" or "streamable_http") One MCP service will use for its proxy endpoint when exporting for this `client_type`. This directly dictates the format of the proxy URL generated by the template (e.g., `base_url/:instance_id/sse` or `base_url/:instance_id/mcp`).
- Users creating `UserConfig` (MCP Setups), adding `ConfigService` instances, and providing `UserOverrideConfigValues`.
- Users exporting an MCP Setup for a chosen `client_type`, triggering a backend process to:
    1. Retrieve service instances.
    2. Calculate effective configurations for each underlying service.
    3. For each instance, use the `ClientConfigTemplates` for the target `client_type`:
        - The `our_proxy_protocol_for_this_client` field from the template detail determines the `effective_our_proxy_protocol`.
        - Render the `template_string`, providing it with data including the effective config of the underlying service and the `effective_our_proxy_protocol`. The template will generate a snippet matching `client_expected_protocol`. The URLs within this snippet will point to One MCP's proxy, constructed using `effective_our_proxy_protocol` (e.g., using `/sse` or `/mcp` path segments).
    4. Aggregate snippets into the final client JSON.

## Key Challenges and Analysis

- **Complex Data Modeling**: Accurately defining `MCPService` (esp. the simplified `ClientConfigTemplates`), `UserConfig`, `ConfigService`.
- **Configuration Merging Logic**: For admin defaults and user overrides.
- **Dynamic Template-Based Transformation**: Templates must:
    - Be selected by `client_type`.
    - Generate snippets matching `client_expected_protocol`.
    - Construct proxy URLs using `our_proxy_protocol_for_this_client` to determine the correct path segment (e.g., `/sse` or `/mcp`).
- **Schema Definition and Validation**: For config schemas.
- **Proxying Logic**: Runtime proxy for `stdio`, `sse`, `streamable_http` underlying services, exposed via One MCP's SSE or Streamable HTTP endpoints (distinguished by URL path, e.g., `/proxy/:instance_id/sse` vs `/proxy/:instance_id/mcp`).
- **API Design**: For Admin, User, and Export (now simpler, no protocol choice param).

**New Challenges for Server Installation Feature:**
- **Multi-Package Manager Integration**: Securely and reliably executing external commands (`npx`, `uvx`) to install packages from different ecosystems. Managing their outputs and error states.
- **Marketplace Search Aggregation & UI**: Designing a user-friendly interface to search across multiple marketplaces (npm, PyPI) and display results effectively. Handling potential differences in package metadata.
- **Installation State Management**: Tracking the installation status of servers and reflecting this in the UI and backend.
- **Dependency Management**: Ensuring that installed servers and their dependencies do not conflict with the One MCP system or other installed servers. (This might be a longer-term consideration).
- **Subtle Page Width Changes**: Investigating and resolving minor page width inconsistencies.
    - **Initial thought**: Caused by scrollbar appearance/disappearance. Global fix `overflow-y-scroll` on `<main>` helped.
    - **Current Hypothesis (Services Page Tabs)**: The width change when switching tabs (e.g., "All Services" vs "Active") on the `ServicesPage` might be due to the tab content's intrinsic width. If a tab's content is narrow (like a short paragraph in "Active"), its container might shrink, causing a perceived page width change, even with `w-full` on parent elements. The `TabsContent` for "All Services" (grid of cards) is wider and might set a different baseline.

## High-level Task Breakdown (Feature: MCP Setup Management & Export with Proxying)

### 1. Core Model Redesign & Implementation
    - **1.1**: Define/Refactor `MCPService` GORM model: `Task Type: New Feature`
        - Fields: `ID`, `Name`, `DisplayName`, `Type` (enum: `stdio`, `sse`, `streamable_http`), `AdminConfigSchema`, `DefaultAdminConfigValues`, `UserConfigSchema`, `AllowUserOverride`, `ClientConfigTemplates` (JSON/TEXT - map of `client_type` to `{ template_string, client_expected_protocol, our_proxy_protocol_for_this_client }`).
        - Success Criteria: Model defined. `ClientConfigTemplates` stores new simplified structured JSON.
    - **1.2**: Define/Refactor `UserConfig` GORM model. `Task Type: New Feature`
    - **1.3**: Define/Refactor `ConfigService` GORM model. `Task Type: New Feature`
    - **1.4**: Implement GORM `AutoMigrate`. `Task Type: New Feature`

### 2. Admin: MCPService Definition Management
    - **2.1**: APIs for Admin to CRUD `MCPService` (including new `ClientConfigTemplates` structure). `Task Type: New Feature`

### 3. User: MCP Setup & Service Instance Management
    - **3.1**: Design & Implement APIs for User to CRUD `UserConfig` (MCP Setups). `Task Type: New Feature`
    - **3.2**: Design & Implement APIs for User to CRUD `ConfigService` (Service Instances). `Task Type: New Feature`
    - **3.3**: Implement logic for handling multi-value inputs. `Task Type: New Feature`

### 4. Core: Configuration Merging & Client Export Logic
    - **4.1**: Implement "Effective Configuration" calculation. `Task Type: New Feature`
    - **4.2**: Design & Implement API for Exporting `UserConfig`: `Task Type: New Feature`
        - Endpoint: `GET /api/mcp_setups/:setup_id/export?client_type=<client_name>` (No `protocol` query param needed).
        - Logic: Retrieves `ClientTemplateDetail` for `client_name`. The `our_proxy_protocol_for_this_client` from this detail becomes the `effective_our_proxy_protocol`.
        - Success Criteria: API authenticates, determines `effective_our_proxy_protocol` solely from `client_type`'s template config.
    - **4.3**: Implement core transformation logic: `Task Type: New Feature`
        - For each instance:
            1. Calculate effective config.
            2. Get `ClientTemplateDetail`.
            3. `effective_our_proxy_protocol = templateDetail.our_proxy_protocol_for_this_client`.
            4. Prepare template data: effective config, `EffectiveOurProxyProtocol: effective_our_proxy_protocol`. Provide means for template to construct correct proxy URL (e.g., by passing base proxy path and `effective_our_proxy_protocol` which template uses to append `/sse` or `/mcp`).
            5. Render `templateDetail.template_string` generating snippet consistent with `templateDetail.client_expected_protocol`.
        - Success Criteria: Generates correct client snippets with proxy URLs reflecting the client-fixed protocol.
    - **4.4**: Implement aggregation. `Task Type: New Feature`

### 5. Core: Service Proxying Runtime
    - **5.1**: Design proxy endpoints. Paths should distinguish protocol, e.g., `/api/proxy/:instance_id/sse` and `/api/proxy/:instance_id/mcp`. `Task Type: New Feature`
    - Success Criteria: Proxy URLs are distinct for SSE and Streamable HTTP, matching what export templates generate.
    - **5.2**: Implement request handling logic for proxy endpoints. `Task Type: New Feature`
    - **5.3**: Implement dispatch logic based on `MCPService.Type` of the underlying service. `Task Type: New Feature`
    - **5.4**: Handle parameter mapping and passing. `Task Type: New Feature`
    - Success Criteria: One MCP service can proxy to underlying services, exposing them via SSE or Streamable HTTP as determined during client config export.

### 6. Testing & Documentation
    - **6.1**: Write unit tests. `Task Type: New Feature`
    - **6.2**: Write integration tests. `Task Type: New Feature`
    - **6.3**: Update API documentation. `Task Type: Refactoring (Functional)`
    - **6.4**: Add code comments. `Task Type: Refactoring (Functional)`

### 7. UI for MCP Server Installation (New Feature Section)
    - **7.1**: Design and implement MCP Server Installation UI (See `.cursor/feature-mcp-installer-ui.md` for details). `Task Type: New Feature`
        - Sub-tasks: UI Mockups, Frontend Component Development, Backend APIs for search & installation, Frontend-Backend Integration, State Management, Testing.
        - Success Criteria: Users can search for MCP servers from npm & PyPI, view details, and trigger installation via `npx`/`uvx` through a user-friendly interface.

### 8. UI Implementation for MCP Installer (Next Major Task)
    - **8.1**: See `.cursor/feature-mcp-installer-ui.md` for detailed UI implementation plan and tasks. `Task Type: New Feature`

### 9. Frontend Routing and Structure Refactor (New Task)
    - **9.1**: Refactor frontend to use `react-router-dom` and separate page components. `Task Type: ref-struct`
        - Sub-tasks: Install `react-router-dom`, create `pages` directory, create page components, migrate content, set up routing in `App.tsx`, update navigation links, remove `currentPage` state.
        - Success Criteria: Application uses URL-based routing, `App.tsx` is cleaner, page logic is modularized.
    - **9.2**: Fix Services page tab width inconsistency. `Task Type: bug-fix`
        - Sub-tasks:
            - **Investigate Computed Widths**: Using browser dev tools, inspect computed widths of `<main>`, `ServicesPage` root div, `<Tabs>`, and `<TabsContent>` elements when switching between "All", "Active", and "Inactive" tabs. Note any changes.
            - **Test with Wider "Active" Content**: Temporarily add wider content (e.g., a long paragraph or a copy of the service grid) to the "Active" tab's `TabsContent` to see if this stabilizes the width.
            - **Test `w-full` on `TabsContent`**: Experimentally add `w-full` to `TabsContent` components to see if it forces them to occupy the full parent width.
            - Implement a CSS or structural fix based on findings (e.g., `min-width` on `TabsContent` or ensuring `Tabs` component itself maintains a consistent width).
        - Success Criteria: Page width remains consistent when switching tabs on the `ServicesPage`.

## Project Status Board

Active Task File: .cursor/feature-routing-refactor.md

- feature-service-management.md: 已完成全局 MCP 客户端管理器相关任务，主流程和单元测试全部通过。
- feature-mcp-installer-ui.md: UI 实现已完成，相关任务已移至归档或标记为完成。
- .cursor/feature-routing-refactor.md: 新增，处理前端路由和结构重构。

# Executor's Feedback or Assistance Requests

**Previous Feedback (Archive - Pre UI Refactor):**
本阶段已完成：
- 全局 MCP 客户端管理器的架构与实现，支持服务注册、查询、卸载、进程管理。
- 相关主流程代码全部通过编译与单元测试。
- 关键接口已通过 Mock 测试覆盖。
- 结构性重构与 bug 修复均已完成。

如需集成测试或新功能开发，可在下一阶段继续。

**Current (UI Routing Refactor & Jest Setup):**
- Refactored `frontend/src/pages/ServicesPage.tsx` to use `useOutletContext` for `setIsOpen` and `useNavigate` for navigation.
- Refactored `frontend/src/pages/DashboardPage.tsx` to use `useNavigate` for its "Quick Actions" navigation.
- The `currentPage` state and `setCurrentPage` prop have now been fully removed from the application logic, with all navigation handled by `react-router-dom`.
- Corrected import paths in `frontend/src/pages/MarketPage.tsx`.
- Added `w-full` to the root `div` of all main page components.
- Changed `overflow-y-auto` to `overflow-y-scroll` on the main content area in `App.tsx`, resolving the page width consistency issue.
- Skeleton pages (`AnalyticsPage`, `ProfilePage`, `PreferencesPage`) have been connected to `PageOutletContext` for potential future use of shared context (e.g., `setIsOpen`).
- **Successfully set up Jest for frontend testing**: Installed dependencies, configured Jest (including mocks for CSS, `TextEncoder`, `window.matchMedia`), and passed an initial smoke test for rendering `AppContent`.
- The primary refactoring work for the `ref-struct` task (routing and page modularization) is now complete.
- **Next Step: Write specific Jest tests** for routing and component interactions to fulfill the testing phase of the current feature. Then, perform comprehensive manual testing.
- **Note on Testing**: Jest setup is complete. Automated tests will now be added.
- **New Bug Reported**: User noted that on the `/services` page, clicking "All Services" and "Active" tabs causes a page width change. This needs investigation and planning.

## Lessons

*   `ClientConfigTemplates` design is crucial. Simplifying it by linking `client_type` directly to `our_proxy_protocol_for_this_client` makes the export process more deterministic and easier to manage if clients have fixed protocol preferences. Templates then need to use this to construct protocol-specific proxy URLs.
*   在使用Thing ORM时，需要为每个模型初始化一个全局变量（如`MCPServiceDB`）并在`InitDB`中调用相应的初始化函数。
*   Thing ORM使用`db`标签而非`gorm`标签定义字段映射和索引。
*   Thing ORM没有内置的`RecordNotFound`错误，需要自定义错误处理。
*   **错误与i18n处理规范：Model层返回i18n key（如`errors.New("user_not_found")`），Handler层根据i18n key和当前语言直接调用i18n.T(lang, err.Error())进行翻译和响应。这样可简化错误处理流程，便于多语言支持和维护。**
*   MCPService模型中未直接使用thing ORM的ToJSON方法进行序列化，原因可能包括：
    1. 仅需序列化部分字段或嵌套结构（如ClientConfigTemplates为string字段，需手动json.Marshal/map转换），直接Marshal更灵活。
    2. ToJSON适合标准结构体/关系型数据的灵活字段导出，若有特殊结构或自定义序列化需求，手动处理更可控。
    3. 目前项目未统一采用ToJSON，部分历史代码/习惯直接用encoding/json。
    4. 若后续需支持灵活字段导出、虚拟字段、嵌套关系等，建议优先用thing.ToJSON+WithFields DSL。
*   thing ORM的ToJSON支持WithFields("field1,nested{subfield},-excluded")等灵活字段控制，适合API导出、前端定制等场景。
*   MCP服务类型说明：
    1. `ServiceTypeStdio` - 本地执行的服务，通过stdin/stdout与服务通信，通常通过包管理器（npm、pypi等）安装
    2. `ServiceTypeSSE` 和 `ServiceTypeStreamableHTTP` - 均为远程服务类型，通过网络请求调用，不需要本地安装。前者使用SSE协议传输数据，后者使用支持流式传输的HTTP协议。
    3. 由于SSE和StreamableHTTP本身即为远端服务类型，无需单独的`ServiceTypeRemote`类型。

## User Specified Lessons

- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Always ask before using the -force git command
- For multi-value config items (e.g., root_path), use JSON arrays for storage and ensure UI/template logic can handle them.