# One MCP Service Development Plan

## Background and Motivation

The goal is to develop an One MCP (Multi-Cloud Platform) Service. This service acts as a central hub for managing and proxying various underlying MCP services (types: `stdio`, `sse`, `streamable_http`). Users configure these underlying services and then access them through unified SSE or Streamable HTTP endpoints provided by this One MCP service. Users create "MCP Setups" (configuration sets) containing multiple service instances. A key feature is exporting these setups into JSON formats specific to different client applications (e.g., Cursor, Cherry-Studio). The exported configurations will always point to the One MCP service's proxy endpoints, and the protocol used by these proxy endpoints (SSE or Streamable HTTP) is determined by the chosen client application type at export time.

This simplified approach streamlines export by tying the proxy protocol choice directly to the client type.

**New: MCP Server Installation User Experience**
The project will also include a user interface for discovering and installing MCP servers, similar to the experience in C-Line and Cherry Studio.
- **User Interface**: A dedicated UI will allow users to browse and search for available MCP servers.
- **Marketplace Integration**:
    - Users will be able to search for MCP servers from public marketplaces like npm (Node Package Manager) and PyPI (Python Package Index).
    - The system will initially feature a curated list of built-in/recommended servers.
- **Installation Mechanism**:
    - Upon selecting a server, the system will use the appropriate command-line tool to install it:
        - `npx` for npm packages (partially supported in backend).
        - `uvx` (or equivalent like `pip install`) for PyPI packages (backend support to be added).
    - The installed server will then be available within the One MCP system for users to configure and use.

The system needs to support:
- Admins defining abstract MCP Service types (`MCPService`), including:
    - The underlying type of the service (`stdio`, `sse`, `streamable_http`).
    - Schemas for admin-level and user-level configurations.
    - Default values for admin configurations.
    - Rules on user overrides.
    - `ClientConfigTemplates` (JSON/TEXT): A map where keys are `client_type` strings (e.g., "cursor", "cherry_studio"). Each value is an object with:
        - `template_string` (string): The Go template for the client-specific JSON snippet.
        - `client_expected_protocol` (string): The protocol type (e.g.,"sse", "streamable_http", "stdio") the client expects for this service entry in its config file.
        - `our_proxy_protocol_for_this_client` (string): The protocol ("sse" or "streamable_http") One MCP service will use for its proxy endpoint when exporting for this `client_type`. This directly dictates the format of the proxy URL generated by the template (e.g., `base_url/:instance_id/sse` or `base_url/:instance_id/mcp`).
- Users creating `UserConfig` (MCP Setups), adding `ConfigService` instances, and providing `UserOverrideConfigValues`.
- Users exporting an MCP Setup for a chosen `client_type`, triggering a backend process to:
    1. Retrieve service instances.
    2. Calculate effective configurations for each underlying service.
    3. For each instance, use the `ClientConfigTemplates` for the target `client_type`:
        - The `our_proxy_protocol_for_this_client` field from the template detail determines the `effective_our_proxy_protocol`.
        - Render the `template_string`, providing it with data including the effective config of the underlying service and the `effective_our_proxy_protocol`. The template will generate a snippet matching `client_expected_protocol`. The URLs within this snippet will point to One MCP's proxy, constructed using `effective_our_proxy_protocol` (e.g., using `/sse` or `/mcp` path segments).
    4. Aggregate snippets into the final client JSON.

## Key Challenges and Analysis

- **Complex Data Modeling**: Accurately defining `MCPService` (esp. the simplified `ClientConfigTemplates`), `UserConfig`, `ConfigService`.
- **Configuration Merging Logic**: For admin defaults and user overrides.
- **Dynamic Template-Based Transformation**: Templates must:
    - Be selected by `client_type`.
    - Generate snippets matching `client_expected_protocol`.
    - Construct proxy URLs using `our_proxy_protocol_for_this_client` to determine the correct path segment (e.g., `/sse` or `/mcp`).
- **Schema Definition and Validation**: For config schemas.
- **Proxying Logic**: Runtime proxy for `stdio`, `sse`, `streamable_http` underlying services, exposed via One MCP's SSE or Streamable HTTP endpoints (distinguished by URL path, e.g., `/proxy/:instance_id/sse` vs `/proxy/:instance_id/mcp`).
- **API Design**: For Admin, User, and Export (now simpler, no protocol choice param).

**New Challenges for Server Installation Feature:**
- **Multi-Package Manager Integration**: Securely and reliably executing external commands (`npx`, `uvx`) to install packages from different ecosystems. Managing their outputs and error states. (Backend support for `uvx`/`pip` needs to be added/enhanced).
- **Marketplace Search Aggregation & UI**: Designing a user-friendly interface to search across multiple marketplaces (npm, PyPI) and display results effectively. Handling potential differences in package metadata.
- **Installation State Management**: Tracking the installation status of servers and reflecting this in the UI and backend (largely in place, may need refinement for PyPI).
- **Dependency Management**: Ensuring that installed servers and their dependencies do not conflict with the One MCP system or other installed servers. (This might be a longer-term consideration).
- **Post-Installation Database Logic**: Ensuring `MCPService` and `ConfigService` records are correctly created/updated in the database after successful installation for all supported package managers.
- **Subtle Page Width Changes**: Investigating and resolving minor page width inconsistencies.
    - **Initial thought**: Caused by scrollbar appearance/disappearance. Global fix `overflow-y-scroll` on `<main>` helped.
    - **Current Hypothesis (Services Page Tabs)**: The width change when switching tabs (e.g., "All Services" vs "Active") on the `ServicesPage` might be due to the tab content's intrinsic width. If a tab's content is narrow (like a short paragraph in "Active"), its container might shrink, causing a perceived page width change, even with `w-full` on parent elements. The `TabsContent` for "All Services" (grid of cards) is wider and might set a different baseline.

**Challenges for Marketplace UI Finalization:**
- Ensuring seamless integration of `ServiceCard.tsx` into `MarketPage.tsx`, including proper data flow and event handling (`onSelect`, `onInstall`).
- Verifying that all service information displays correctly under various conditions (e.g., missing optional data like GitHub stars).
- Confirming that the installation initiation from the card works as expected and UI updates reflect installation status.

## High-level Task Breakdown (Feature: MCP Setup Management & Export with Proxying)

### 1. Core Model Redesign & Implementation
    - **1.1**: Define/Refactor `MCPService` GORM model: `Task Type: New Feature`
        - Fields: `ID`, `Name`, `DisplayName`, `Type` (enum: `stdio`, `sse`, `streamable_http`), `AdminConfigSchema`, `DefaultAdminConfigValues`, `UserConfigSchema`, `AllowUserOverride`, `ClientConfigTemplates` (JSON/TEXT - map of `client_type` to `{ template_string, client_expected_protocol, our_proxy_protocol_for_this_client }`).
        - Success Criteria: Model defined. `ClientConfigTemplates` stores new simplified structured JSON.
    - **1.2**: Define/Refactor `UserConfig` GORM model. `Task Type: New Feature`
    - **1.3**: Define/Refactor `ConfigService` GORM model. `Task Type: New Feature`
    - **1.4**: Implement GORM `AutoMigrate`. `Task Type: New Feature`

### 2. Admin: MCPService Definition Management
    - **2.1**: APIs for Admin to CRUD `MCPService` (including new `ClientConfigTemplates` structure). `Task Type: New Feature`

### 3. User: MCP Setup & Service Instance Management
    - **3.1**: Design & Implement APIs for User to CRUD `UserConfig` (MCP Setups). `Task Type: New Feature`
    - **3.2**: Design & Implement APIs for User to CRUD `ConfigService` (Service Instances). `Task Type: New Feature`
    - **3.3**: Implement logic for handling multi-value inputs. `Task Type: New Feature`

### 4. Core: Configuration Merging & Client Export Logic
    - **4.1**: Implement "Effective Configuration" calculation. `Task Type: New Feature`
    - **4.2**: Design & Implement API for Exporting `UserConfig`: `Task Type: New Feature`
        - Endpoint: `GET /api/mcp_setups/:setup_id/export?client_type=<client_name>` (No `protocol` query param needed).
        - Logic: Retrieves `ClientTemplateDetail` for `client_name`. The `our_proxy_protocol_for_this_client` from this detail becomes the `effective_our_proxy_protocol`.
        - Success Criteria: API authenticates, determines `effective_our_proxy_protocol` solely from `client_type`'s template config.
    - **4.3**: Implement core transformation logic: `Task Type: New Feature`
        - For each instance:
            1. Calculate effective config.
            2. Get `ClientTemplateDetail`.
            3. `effective_our_proxy_protocol = templateDetail.our_proxy_protocol_for_this_client`.
            4. Prepare template data: effective config, `EffectiveOurProxyProtocol: effective_our_proxy_protocol`. Provide means for template to construct correct proxy URL (e.g., by passing base proxy path and `effective_our_proxy_protocol` which template uses to append `/sse` or `/mcp`).
            5. Render `templateDetail.template_string` generating snippet consistent with `templateDetail.client_expected_protocol`.
        - Success Criteria: Generates correct client snippets with proxy URLs reflecting the client-fixed protocol.
    - **4.4**: Implement aggregation. `Task Type: New Feature`

### 5. Core: Service Proxying Runtime
    - **5.1**: Design proxy endpoints. Paths should distinguish protocol, e.g., `/api/proxy/:instance_id/sse` and `/api/proxy/:instance_id/mcp`. `Task Type: New Feature`
    - Success Criteria: Proxy URLs are distinct for SSE and Streamable HTTP, matching what export templates generate.
    - **5.2**: Implement request handling logic for proxy endpoints. `Task Type: New Feature`
    - **5.3**: Implement dispatch logic based on `MCPService.Type` of the underlying service. `Task Type: New Feature`
    - **5.4**: Handle parameter mapping and passing. `Task Type: New Feature`
    - Success Criteria: One MCP service can proxy to underlying services, exposing them via SSE or Streamable HTTP as determined during client config export.

### 6. Testing & Documentation
    - **6.1**: Write unit tests. `Task Type: New Feature`
    - **6.2**: Write integration tests. `Task Type: New Feature`
    - **6.3**: Update API documentation. `Task Type: Refactoring (Functional)`
    - **6.4**: Add code comments. `Task Type: Refactoring (Functional)`

### 7. UI for MCP Server Installation (New Feature Section)
    - **7.1**: Design and implement MCP Server Installation UI (See `.cursor/feature-mcp-installer-ui.md` for details). `Task Type: New Feature`
        - Sub-tasks: UI Mockups, Frontend Component Development, Backend APIs for search & installation, Frontend-Backend Integration, State Management, Testing.
        - Success Criteria: Users can search for MCP servers from npm & PyPI, view details, and trigger installation via `npx`/`uvx` through a user-friendly interface.

### 8. UI Implementation for MCP Installer (Next Major Task)
    - **8.1**: See `.cursor/feature-mcp-installer-ui.md` for detailed UI implementation plan and tasks. `Task Type: New Feature`

### 9. Frontend Routing and Structure Refactor (New Task)
    - **9.1**: Refactor frontend to use `react-router-dom` and separate page components. `Task Type: ref-struct`
        - Sub-tasks: Install `react-router-dom`, create `pages` directory, create page components, migrate content, set up routing in `App.tsx`, update navigation links, remove `currentPage` state.
        - Success Criteria: Application uses URL-based routing, `App.tsx` is cleaner, page logic is modularized.
    - **9.2**: Fix Services page tab width inconsistency. `Task Type: bug-fix`
        - Sub-tasks:
            - **Investigate Computed Widths**: Using browser dev tools, inspect computed widths of `<main>`, `ServicesPage` root div, `<Tabs>`, and `<TabsContent>` elements when switching between "All", "Active", and "Inactive" tabs. Note any changes.
            - **Test with Wider "Active" Content**: Temporarily add wider content (e.g., a long paragraph or a copy of the service grid) to the "Active" tab's `TabsContent` to see if this stabilizes the width.
            - **Test `w-full` on `TabsContent`**: Experimentally add `w-full` to `TabsContent` components to see if it forces them to occupy the full parent width.
            - Implement a CSS or structural fix based on findings (e.g., `min-width` on `TabsContent` or ensuring `Tabs` component itself maintains a consistent width).
        - Success Criteria: Page width remains consistent when switching tabs on the `ServicesPage`.

### 10. UI Polish and Bug Fixing (New Task)
    - **10.1**: Address UI bugs and implement minor UI enhancements. See `.cursor/ui-polish-tasks.md` for details. `Task Type: bug-fix`

### 11. Feature: Backend Support for MCP Server Installation (npm, PyPI/uvx)
    - **11.1**: Implement backend logic for installing MCP servers from npm (enhance existing) and PyPI/uvx (new). See `.cursor/feature-backend-installer.md` for details. `Task Type: new-feat`
    - **Success Criteria**: Backend can reliably install packages using npx and uvx/pip, manage installation state, and update database records. Frontend can integrate with these backend APIs.

### 12. Frontend: Service Card Display Refinement (New Task)
    - **12.1**: Refine the display of information on the `ServiceCard` component in the marketplace. See `.cursor/feature-service-card-refine.md` for details. `Task Type: ref-func`
    - **Success Criteria**: Service cards accurately reflect desired information like GitHub homepage, adjusted star/author display, and removal of download counts. (Status: Completed)

### 13. Frontend: Finalize Marketplace UI (Integrate ServiceCard, Test) (New Task)
    - **13.1**: Integrate `ServiceCard.tsx` into `MarketPage.tsx` and conduct comprehensive UI testing. See `.cursor/feature-marketplace-ui-finalization.md` for details. `Task Type: new-feat`
    - **Success Criteria**: Marketplace UI uses the new `ServiceCard.tsx`, displays information correctly, and all user interactions (search, select, install) are functional and smooth.

### 14. Backend: Implement GitHub Data Fetching (Stars, Author) (Future Task)
    - **14.1**: Enhance backend to fetch GitHub stars and potentially parse author information from GitHub repository URLs. Define a task file (e.g., `.cursor/feature-backend-github.md`) when this becomes active. `Task Type: new-feat`
    - **Success Criteria**: Backend marketplace API provides GitHub stars and improved author information for services where applicable.

### 15. Frontend: Login Experience Refactor (Completed)
    - **15.1**: Standardize UI/UX for standalone login page and login modal, ensure correct token persistence. See `.cursor/login-refactor-tasks.md` for details. `Task Type: ref-struct/new-feat/bug-fix`
    - **Success Criteria**: Login page and modal are visually and functionally identical; token handling is correct and robust.

### 16. Feature: Service Uninstallation (Active)
    - **16.1**: Implement the ability for users to uninstall services from the marketplace. See `.cursor/feature-uninstall-service-tasks.md` for details. `Task Type: new-feat`
    - **Success Criteria**: Users can successfully uninstall services, with appropriate feedback and state changes in UI and backend.

## Project Status Board

Active Task File: `.cursor/feature-uninstall-service-tasks.md`

Relevant Task Files:
*   `.cursor/login-refactor-tasks.md`: Login experience refactor (All tasks completed).
*   `.cursor/feature-uninstall-service-tasks.md`: Service Uninstallation feature (Active).
*   feature-service-card-refine.md: (Status: Completed)
*   feature-marketplace-ui-finalization.md: (Status: Active) Frontend work to integrate ServiceCard.tsx and test marketplace UI.

# One MCP AI Agent Scratchpad

## Background and Motivation

User wants to unify the login experience between the standalone `/login` page and the login modal. Currently, they differ in UI and token handling, with the `/login` page not correctly persisting the token to the global state (AuthContext).
Additionally, user requested a new feature to uninstall services from the marketplace, and visual enhancements for the installation process (toast notification and a success checkmark animation).

## Key Challenges and Analysis

**Login Refactor:**
1.  **UI/UX Unification**: `Login.tsx` needs to replicate or reuse the visual and interactive elements of `login-dialog.tsx`.
2.  **Logic Reusability**: `login-dialog.tsx` contains form handling, API calls, error management, and global state updates via `useAuth().login`. `Login.tsx` must use this logic.
3.  **Token Persistence**: Ensure `/login` page uses `useAuth().login` for consistent token handling in `localStorage` and `AuthContext`.
4.  **Component Reuse Strategy**: Recommended creating a `LoginFormCommon.tsx` to be used by both `login-dialog.tsx` (for modal) and `Login.tsx` (for standalone page).

**Service Uninstallation:**
1.  **Backend API**: Requires a new endpoint to handle uninstallation commands and database updates.
2.  **Frontend State**: `marketStore` needs to manage uninstallation status.
3.  **UI/UX**: "Uninstall" button, confirmation dialog, and feedback (toasts, loading states).

**Installation Animation:**
1.  Display a toast "Installing..." on initiation.
2.  On success, show a large, semi-transparent checkmark SVG animation in the center of the service card, which then fades out.

## High-level Task Breakdown

1.  **Create Login Form Common Component (`ref-struct`)**: 详见 `.cursor/login-refactor-tasks.md`
2.  **Refactor Login Modal (`ref-struct`)**: 详见 `.cursor/login-refactor-tasks.md`
3.  **Refactor Standalone Login Page (`new-feat` / `ref-func`)**: 详见 `.cursor/login-refactor-tasks.md`
4.  **Test and Verify (`bug-fix`)**: 详见 `.cursor/login-refactor-tasks.md`

## Project Status Board

Active Task File: `.cursor/feature-uninstall-service-tasks.md`

Relevant Task Files:
*   `.cursor/login-refactor-tasks.md`: Login experience refactor (All tasks completed).
*   `.cursor/feature-uninstall-service-tasks.md`: Service Uninstallation feature (Active).
*   feature-service-card-refine.md: (Status: Completed)
*   feature-marketplace-ui-finalization.md: (Status: Active) Frontend work to integrate ServiceCard.tsx and test marketplace UI.

## Lessons

*   `ClientConfigTemplates` design is crucial. Simplifying it by linking `client_type` directly to `our_proxy_protocol_for_this_client` makes the export process more deterministic and easier to manage if clients have fixed protocol preferences. Templates then need to use this to construct protocol-specific proxy URLs.
*   在使用Thing ORM时，需要为每个模型初始化一个全局变量（如`MCPServiceDB`）并在`InitDB`中调用相应的初始化函数。
*   Thing ORM使用`db`标签而非`gorm`标签定义字段映射和索引。
*   Thing ORM没有内置的`RecordNotFound`错误，需要自定义错误处理。
*   **错误与i18n处理规范：Model层返回i18n key（如`errors.New("user_not_found")`），Handler层根据i18n key和当前语言直接调用i18n.T(lang, err.Error())进行翻译和响应。这样可简化错误处理流程，便于多语言支持和维护。**
*   MCPService模型中未直接使用thing ORM的ToJSON方法进行序列化，原因可能包括：
    1. 仅需序列化部分字段或嵌套结构（如ClientConfigTemplates为string字段，需手动json.Marshal/map转换），直接Marshal更灵活。
    2. ToJSON适合标准结构体/关系型数据的灵活字段导出，若有特殊结构或自定义序列化需求，手动处理更可控。
    3. 目前项目未统一采用ToJSON，部分历史代码/习惯直接用encoding/json。
    4. 若后续需支持灵活字段导出、虚拟字段、嵌套关系等，建议优先用thing.ToJSON+WithFields DSL。
*   thing ORM的ToJSON支持WithFields("field1,nested{subfield},-excluded")等灵活字段控制，适合API导出、前端定制等场景。
*   MCP服务类型说明：
    1. `ServiceTypeStdio` - 本地执行的服务，通过stdin/stdout与服务通信，通常通过包管理器（npm、pypi等）安装
    2. `ServiceTypeSSE` 和 `ServiceTypeStreamableHTTP` - 均为远程服务类型，通过网络请求调用，不需要本地安装。前者使用SSE协议传输数据，后者使用支持流式传输的HTTP协议。
    3. 由于SSE和StreamableHTTP本身即为远端服务类型，无需单独的`ServiceTypeRemote`类型。
*   Redis 缓存极大提升了 stars 聚合性能和抗限流能力。
*   .env 文件被 .gitignore 忽略，敏感信息不应纳入版本控制。
*   Go 单元测试用 SQLite 内存数据库时，ORM 全局和 model 层必须共用同一个 dbAdapter，不能多次 new，避免 :memory: 连接隔离。推荐在测试用例里只 new 一次 dbAdapter，并传给 ORM 和 model，所有表结构和数据操作都在同一连接下完成。

## User Specified Lessons

- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Always ask before using the -force git command
- For multi-value config items (e.g., root_path), use JSON arrays for storage and ensure UI/template logic can handle them.

- 已修复 AppContent 测试断言，允许页面上有多个 'One MCP' 元素，测试已通过并已提交。

## Background and Motivation

为提升服务卡片的权威性和用户体验，需要在前端展示 npm 包对应 GitHub 仓库的 star 数。当前 npm registry API 不直接返回 stars，需后端聚合采集并返回。

## Key Challenges and Analysis

- 需解析 npm 包 repository 字段，兼容多种格式，准确提取 GitHub owner/repo。
- 需调用 GitHub API 获取 stars，处理速率限制和 token 配置。
- 需保证 stars 字段与前端字段名对齐（github_stars）。
- 需兜底处理 API 失败、无 stars 情况。

## High-level Task Breakdown

- 前端 UI 及数据 mapping 已完成。
- 后端需补充 npm 包 GitHub stars 聚合逻辑（详见 .cursor/feature-service-card-refine.md Task 3）。

## Project Status Board

Active Task File: feature-service-card-refine.md
- Task 3: 聚合并返回 npm 包的 GitHub stars（In Progress）

### 🎉 服务卡片 GitHub stars 聚合与缓存链路——验收总结

1. **核心目标达成**
   - 后端已实现 npm 包 GitHub stars 字段自动聚合，优先用 Redis 缓存，极大提升了性能和抗限流能力。
   - 前端/后端接口 contract 完全对齐字段名和 contract 满足 UI 需求。
   - stars 字段能稳定返回真实 star 数，重复请求命中缓存，接口高性能、低延迟。

2. **用户体验优化**
   - 只需设置 JWT_SECRET，重启后端不会导致前端登录态丢失，用户体验大幅提升。

3. **代码与文档**
   - 相关代码已自动 commit，文档、lessons、任务板均已同步更新。

4. **遗留问题与建议**
   - backend/library/market/pypi_test.go 存在语法错误，建议后续单独修复。
   - Redis dump.rdb 文件出现在根目录，属正常现象，可通过配置调整。
   - 若需进一步优化缓存策略、支持多用户 token、前端 token 配置等，可后续补充。

# MCP Service Marketplace Enhancements & Fixes

## Background and Motivation
The project aims to enhance the service marketplace UI/UX, particularly around service installation involving environment variables.
Key requirements:
1.  If backend API `/mcp_market/install_or_add_service` indicates missing environment variables (e.g., `FIRECRAWL_API_KEY`), the frontend should display a modal for the user to input these variables, rather than just showing a toast message.
2.  The backend API was updated to return `{ success: true, data: { required_env_vars: [...] } }` (HTTP 200) when env vars are missing, instead of a 400 error.
3.  Frontend should handle this response by showing an `EnvVarInputModal`.
4.  Users should be able to cancel the modal, and the install button should reset to an "Install" state (not get stuck on "Installing...").
5.  When users submit the modal with entered variables, these variables must be correctly included in the subsequent installation API request.

## Key Challenges and Analysis
- **API Contract Synchronization:** Ensuring frontend and backend agree on response structures for missing env vars. (Initially an issue, now backend returns 200 with `required_env_vars` in `data`).
- **State Management for Modal:** Correctly managing visibility (`envModalVisible`), missing variable names (`missingVars`), and temporarily held variables (`pendingEnvVars`, `pendingServiceId`) in `ServiceMarketplace.tsx`.
- **Store State for Installation Task:** The `installTasks` in `marketStore.ts` (Zustand) tracks the status of each installation. This status (`installing`, `success`, `error`, `idle`) dictates UI elements like button states.
- **Recursive Installation Flow:** When the modal is submitted, `handleEnvModalSubmit` calls `handleInstallService` again. This recursive call needs to:
    - Have its installation status correctly reset (e.g., to 'idle' in `installTasks`) before the recursive call to avoid "already in progress" errors from the store.
    - Correctly carry forward both previously accumulated `pendingEnvVars` and the new `userInputVars` from the modal.
- **Variable Propagation:** Ensuring the variables entered by the user in the modal (`userInputVars`) are correctly merged with any `pendingEnvVars` and passed through `handleInstallService` to the `installService` action in the store, and finally included in the `user_provided_env_vars` field of the API request body. The user reported an issue where newly entered variables were not appearing in the submission.

## High-level Task Breakdown
1.  **Feature: Environment Variable Input Modal** - Task File: `.cursor/feature-env-var-modal.md` (Largely completed)
    *   Backend API adjustment for env var responses.
    *   Frontend `EnvVarInputModal` component creation.
    *   Logic in `ServiceMarketplace.tsx` to show modal.
    *   Type and data flow fixes in `marketStore.ts` and API calls.
2.  **BugFix: Install Button Stuck on "Installing..." after Modal Cancel** - Task File: `.cursor/bugfix-install-button-stuck.md` (Completed)
    *   Reset `installTasks[serviceId].status` to 'idle' when modal is cancelled.
3.  **BugFix: Variables Not Submitted After Modal Input** - Task File: `.cursor/fix-env-var-submission.md` (Active)
    *   Verify variable capture in Modal.
    *   Verify variable merging and passing in `ServiceMarketplace.tsx`.
    *   Verify variable reception and usage in `marketStore.ts`.
    *   Ensure the HTTP request payload is correct.

## Project Status Board
- **Active Task File:** `.cursor/fix-env-var-submission.md`
- `feature-env-var-modal.md`: Completed
- `bugfix-install-button-stuck.md`: Completed

## Executor's Feedback or Assistance Requests
- Waiting for approval to apply logging and fixes for env var submission.

## Lessons
- Axios interceptors can alter the shape of API responses; ensure store actions and component logic are consistent with the actual data structure returned by the API client.
- When dealing with multi-step operations (like install -> input env -> re-install), carefully manage and reset intermediate states (e.g., installation task status) to allow the flow to proceed correctly.
- Explicitly log data at each step of a complex flow to verify propagation.

## User Specified Lessons
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Always ask before using the -force git command

### 服务市场与服务管理分工、环境变量配置与权限机制（2024-05-XX 补充）

本阶段目标是实现服务市场（Service Marketplace）与服务管理（Services）页面的分工重构，以及环境变量配置弹窗、后端接口与权限机制的完善。具体包括：
- Service Marketplace 仅做"发现/安装"，移除"已安装""PyPI""Recommended"tab，仅保留 All/NPM。
- Services 页面专注"管理/配置/统计"，数据源切换为 store 的 fetchInstalledServices，支持"全部/Active/Inactive"tab，按服务状态过滤。
- 安装服务时，若后端返回缺少环境变量，前端弹出 EnvVarInputModal 让用户补全。
- 新增 ServiceConfigModal 组件，支持展示/编辑所有环境变量、逐项保存、SSE/HTTP endpoint 展示与一键复制。
- 后端接口 /api/mcp_market/installed 返回 env_vars 字段，PATCH /api/mcp_market/env_var 支持单独保存服务环境变量。
- 环境变量无默认值，只有"管理员共享"与"用户私有"两种模式，权限与数据流同步调整。

## Key Challenges and Analysis

### 服务市场/服务管理分工与环境变量权限机制（2024-05-XX 补充）

- 前后端需严格区分"发现/安装"与"管理/配置"两大页面的数据流和交互，避免混淆。
- 环境变量配置需支持"管理员共享"与"用户私有"两级，无默认值，优先级为：用户私有 > 管理员共享 > 空。
- 仅管理员可切换共享状态，普通用户只能填写自己的值，不能更改共享状态。
- 后端需在 ConfigService 增加 is_shared 字段，接口查询/保存时需做权限校验。
- 前端 ServiceConfigModal 需根据权限渲染锁图标、只读/可编辑状态。
- 多用户场景下需确保数据隔离与权限安全。
- UI 需优化弹窗、按钮、endpoint 复制等细节，提升交互体验。

## High-level Task Breakdown

### 服务市场/服务管理分工与环境变量权限机制（2024-05-XX 补充）

- Marketplace 页面重构，仅保留 All/NPM tab，聚焦服务发现与安装。
- Services 页面重构，数据源切换为 store 的 fetchInstalledServices，支持按状态过滤。
- 环境变量弹窗与配置：
    - 安装服务时缺少变量弹 EnvVarInputModal。
    - Services 页面支持 ServiceConfigModal，展示/编辑所有变量，逐项保存。
    - 支持 endpoint 一键复制与反馈。
- 后端接口调整：
    - /api/mcp_market/installed 返回 env_vars 字段。
    - PATCH /api/mcp_market/env_var 支持单独保存变量，参数 service_id, var_name, var_value。
    - ConfigService 增加 is_shared 字段，权限校验与优先级逻辑。
- 权限与共享机制：
    - 管理员可切换变量共享状态，普通用户只能填写私有值。
    - 查询优先级：用户私有 > 管理员共享 > 空。
    - 前端 UI 按权限渲染交互。
- 任务文档与状态同步，便于后续迭代。

## Project Status Board

Active Task File: feature-marketplace-services-split.md

- feature-marketplace-services-split.md: 服务市场/服务管理分工与环境变量权限机制重构，进行中。

- 服务环境变量编辑功能已完成，PATCH /api/mcp_market/env_var 路由已注册，前端 UI/交互/保存均已通过验收。