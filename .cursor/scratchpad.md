# One MCP Service Development Plan

## Background and Motivation

The goal is to develop an One MCP (Multi-Cloud Platform) Service. This service acts as a central hub for managing and proxying various underlying MCP services (types: `stdio`, `sse`, `streamable_http`). Users configure these underlying services and then access them through unified SSE or Streamable HTTP endpoints provided by this One MCP service. Users create "MCP Setups" (configuration sets) containing multiple service instances. A key feature is exporting these setups into JSON formats specific to different client applications (e.g., Cursor, Cherry-Studio). The exported configurations will always point to the One MCP service's proxy endpoints, and the protocol used by these proxy endpoints (SSE or Streamable HTTP) is determined by the chosen client application type at export time.

This simplified approach streamlines export by tying the proxy protocol choice directly to the client type.

**New: MCP Server Installation User Experience**
The project will also include a user interface for discovering and installing MCP servers, similar to the experience in C-Line and Cherry Studio.
- **User Interface**: A dedicated UI will allow users to browse and search for available MCP servers.
- **Marketplace Integration**:
    - Users will be able to search for MCP servers from public marketplaces like npm (Node Package Manager) and PyPI (Python Package Index).
    - The system will initially feature a curated list of built-in/recommended servers.
- **Installation Mechanism**:
    - Upon selecting a server, the system will use the appropriate command-line tool to install it:
        - `npx` for npm packages (partially supported in backend).
        - `uvx` (or equivalent like `pip install`) for PyPI packages (backend support to be added).
    - The installed server will then be available within the One MCP system for users to configure and use.

The system needs to support:
- Admins defining abstract MCP Service types (`MCPService`), including:
    - The underlying type of the service (`stdio`, `sse`, `streamable_http`).
    - Schemas for admin-level and user-level configurations.
    - Default values for admin configurations.
    - Rules on user overrides.
    - `ClientConfigTemplates` (JSON/TEXT): A map where keys are `client_type` strings (e.g., "cursor", "cherry_studio"). Each value is an object with:
        - `template_string` (string): The Go template for the client-specific JSON snippet.
        - `client_expected_protocol` (string): The protocol type (e.g.,"sse", "streamable_http", "stdio") the client expects for this service entry in its config file.
        - `our_proxy_protocol_for_this_client` (string): The protocol ("sse" or "streamable_http") One MCP service will use for its proxy endpoint when exporting for this `client_type`. This directly dictates the format of the proxy URL generated by the template (e.g., `base_url/:instance_id/sse` or `base_url/:instance_id/mcp`).
- Users creating `UserConfig` (MCP Setups), adding `ConfigService` instances, and providing `UserOverrideConfigValues`.
- Users exporting an MCP Setup for a chosen `client_type`, triggering a backend process to:
    1. Retrieve service instances.
    2. Calculate effective configurations for each underlying service.
    3. For each instance, use the `ClientConfigTemplates` for the target `client_type`:
        - The `our_proxy_protocol_for_this_client` field from the template detail determines the `effective_our_proxy_protocol`.
        - Render the `template_string`, providing it with data including the effective config of the underlying service and the `effective_our_proxy_protocol`. The template will generate a snippet matching `client_expected_protocol`. The URLs within this snippet will point to One MCP's proxy, constructed using `effective_our_proxy_protocol` (e.g., using `/sse` or `/mcp` path segments).
    4. Aggregate snippets into the final client JSON.

## Key Challenges and Analysis

- **Complex Data Modeling**: Accurately defining `MCPService` (esp. the simplified `ClientConfigTemplates`), `UserConfig`, `ConfigService`.
- **Configuration Merging Logic**: For admin defaults and user overrides.
- **Dynamic Template-Based Transformation**: Templates must:
    - Be selected by `client_type`.
    - Generate snippets matching `client_expected_protocol`.
    - Construct proxy URLs using `our_proxy_protocol_for_this_client` to determine the correct path segment (e.g., `/sse` or `/mcp`).
- **Schema Definition and Validation**: For config schemas.
- **Proxying Logic**: Runtime proxy for `stdio`, `sse`, `streamable_http` underlying services.
   - Proxied services (notably Stdio-based services exposed over SSE) are accessed via paths like `/proxy/:serviceName/sse/*action`.
   - The exact path structure depends on the Gin router setup for these proxy endpoints.
   - `:serviceName` is the unique name of the service instance.
- **API Design**: For Admin, User, and Export. 
   - Proxy endpoints for services follow a pattern like `/proxy/:serviceName/sse/*action` for SSE-proxied Stdio services. Streamable HTTP proxy paths would follow a similar convention (e.g., `/proxy/:serviceName/http/*action`) if implemented.

## MCPService Refactor and Test Debugging (StdioConfig Sourcing)

During the refactoring of `MCPService` to remove deprecated fields (`DefaultAdminConfigValues`, `AdminConfigSchema`, `UserConfigSchema`) and utilize new fields (`Command`, `ArgsJSON`, `DefaultEnvsJSON`) for `StdioConfig` generation, several key points were noted